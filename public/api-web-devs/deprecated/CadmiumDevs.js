'use strict';

import Core from '../tools/core.js';
import Parser from "./parser.js";

import { Simulation, TransitionDEVS, TransitionsDEVS, Diagram, Options, Files } from './files.js';

import Settings from '../components/settings.js';

export default class CadmiumDEVS extends Parser { 
		
	Parse(files) {
		var d = Core.Defer();

		var sim = files.find(function(f) { return f.name.match(/.json/i); });
		var svg = files.find(function(f) { return f.name.match(/.svg/i); });
		var log = files.find(function(f) { return f.name.match(/.txt/i); });

		if (!sim || !log) {
			d.Reject(new Error("A model (.json) and a log (.log) file must be provided for the Cadmium DEVS parser."));
		
			return d.promise;
		}
		
		var name = log.name.substr(0, log.name.length - 4);
		
		//-----------------------------------------------------------------
		this.Read(sim, this.ParseSimFile.bind(this)).then((sim) => {
			// var simulation = new Simulation(name, "CDpp", "DEVS", ma.models, ma.size);
			this.simulation = new Simulation(name, "Cadmium", "DEVS", sim.models, sim.size);
			
			var p1 = this.Read(svg, this.ParseSVGFile.bind(this));
			var p2 = this.ReadByChunk(log, this.ParseLogChunk.bind(this));
			var defs = [p1, p2];
		

			Promise.all(defs).then((data) => {
				var svg = data [0];
				var log = data [1];
				if (!svg) return d.Reject(new Error("Unable to parse the model (.svg) file."));
				if (!log) return d.Reject(new Error("Unable to parse the log (.log) file."));
				
				var transitions = new TransitionsDEVS(log);
				var diagram = new Diagram(svg);
				var options = new Options(Settings.Default());
				
				// var files = new Files(simulation, transitions, diagram, options);
				var files = new Files(this.simulation, transitions, diagram, options);

				d.Resolve(files);
			}, (error) => {
				d.Reject(error);
			});
		});

		return d.promise;
	}

	ParseSimFile(file) {		//Adapt later. It's already json, I don't think we need to parse.
		return file;
	}
	
	ParseSVGFile( file) {	
		return file;
	}
	
	ParseLogChunk(parsed, chunk) {		

		var start = 0;		
		
		while (start < chunk.length) {				
			var end = chunk.indexOf('\n', start);
			
			if (end == -1) end = chunk.length + 1;
			
			var line = chunk.substr(start, end - start);
			
			if (line.startsWith("[")) {
				// parse model name
				var patt = " generated by model ";
				var tokens = line.split(patt);
				var m=tokens[1];

				// parse messages
				var tokens2 = tokens[0].split(',');

				for (var i = 0; i <tokens2.length; i++) {
					var aux = tokens2[i].substr(1,tokens2[i].length);

					var tokens3 = aux.split('{');

					var p_aux = tokens3[0].substr(0,tokens3[0].length - 2 );

					var tokens4=p_aux.split(":");

					var p = tokens4[tokens4.length -1];

					var v = tokens3[1].substr(0,tokens3[1].indexOf("}"))

					if (v!= "" & v!= "{"){
						parsed.push(new TransitionDEVS(this.time, m, p, v));
					}
				}
			}
			else this.time = line;
			
			var start = start + line.length + 1;
		};
		
		return parsed;

	}
}